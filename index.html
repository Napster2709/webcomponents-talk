<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />

    <title>Webcomponents</title>

    <link rel="stylesheet" href="dist/reset.css" />
    <link rel="stylesheet" href="dist/reveal.css" />
    <link rel="stylesheet" href="dist/theme/night.css" />

    <!-- Theme used for syntax highlighted code -->
    <link rel="stylesheet" href="plugin/highlight/monokai.css" />
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <section>
          <h2>Webcomponents & LIT</h2>
        </section>
        <section>
          <section>
            <h2>Webcomponents</h2>
          </section>
          <section data-auto-animate>
            <h5>what are web components?</h5>
            <blockquote class="fragment fade-up">
              <p>
                Web Components are a set of web platform APIs that enable
                developers to create
                <strong>reusable, custom HTML elements</strong> with
                encapsulated functionality and styling.
              </p>
            </blockquote>
          </section>
          <section data-auto-animate>
            <h3>Example</h3>
            <pre class="marker">Basic</pre>
            <pre
              data-id="code"
            ><code data-line-numbers="1-5" class="hljs">class MyAwesomeComponent extends HTMLElement {
  //
}

customElements.define("my-awesome-component", MyAwesomeComponent);
            </code></pre>
          </section>
          <section data-auto-animate>
            <h3>Example</h3>
            <pre class="marker">Basic</pre>
            <pre
              data-id="code"
            ><code data-line-numbers="1-5" class="hljs">class MyAwesomeComponent extends HTMLParagraphElement {
  //
}

customElements.define("my-awesome-component", MyAwesomeComponent);
            </code></pre>
          </section>
          <section data-auto-animate>
            <h3>Example</h3>
            <pre class="marker">Basic</pre>
            <pre
              data-id="code"
            ><code data-line-numbers="1-5" class="hljs">class MyAwesomeComponent extends MyAbstructClass {
  //
}

customElements.define("my-awesome-component", MyAwesomeComponent);
            </code></pre>
          </section>
          <section data-auto-animate>
            <h3>Example</h3>
            <pre class="marker">Basic</pre>
            <pre
              data-id="code"
            ><code data-line-numbers="1-5|5" class="hljs">class MyAwesomeComponent extends HTMLElement {
  //
}

customElements.define("my-awesome-component", MyAwesomeComponent);
            </code></pre>
          </section>
          <section data-auto-animate>
            <h3>Example</h3>
            <pre class="marker">usage</pre>
            <pre data-id="code"><code data-line-numbers class="hljs" data-trim>
              <script type="module" src="<path-to-my-awesome-component>.(m)js"></script>
              ...
              <my-awesome-component></my-awesome-component>
            </code></pre>
          </section>
          <section data-auto-animate>
            <h3>Example</h3>
            <pre class="marker">shadow-dom</pre>
            <pre
              data-id="code"
            ><code data-line-numbers="1-5" class="hljs">class MyAwesomeComponent extends HTMLElement {
  //
}

customElements.define("my-awesome-component", MyAwesomeComponent);
            </code></pre>
          </section>
          <section data-auto-animate>
            <h3>Example</h3>
            <pre class="marker">shadow-dom</pre>
            <pre
              data-id="code"
            ><code data-line-numbers="1-9|4|4-5" class="hljs">class MyAwesomeComponent extends HTMLElement {
  constructor() {
    super();
    const shadow = this.attachShadow({ mode: "open" });
    shadow.innerHTML = `<p>Hello from Shadow DOM!</p>`;
  }
}

customElements.define("my-awesome-component", MyAwesomeComponent);
            </code></pre>
          </section>
          <section data-auto-animate>
            <h3>Example</h3>
            <pre class="marker">events</pre>
            <pre
              data-id="code"
            ><code data-line-numbers="1-19|8-14" class="language-javascript">class MyAwesomeComponent extends HTMLElement {
  constructor() {
    super();
    const shadow = this.attachShadow({ mode: "open" });
    const button = document.createElement("button");

    button.textContent = "Click me!";
    button.addEventListener("click", () => {
      this.dispatchEvent(
        new CustomEvent("custom-event", {
          detail: "Hello World!"
        })
      );
    });
    shadow.appendChild(button);
  }
}

customElements.define("my-awesome-component", MyAwesomeComponent);
            </code></pre>
          </section>
          <section data-auto-animate>
            <h3>Example</h3>
            <pre class="marker">usage</pre>
            <pre
              data-id="code"
            ><code data-line-numbers class="hljs"><script type="module" src="<path-to-my-awesome-component>.(m)js"></script>
...
<my-awesome-component></my-awesome-component>
            </code></pre>
          </section>
          <section data-auto-animate>
            <h3>Example</h3>
            <pre class="marker">usage</pre>
            <pre
              data-id="code"
            ><code data-line-numbers="1-9|5-8" class="hljs"><script type="module" src="<path-to-my-awesome-component>.(m)js"></script>
...
<my-awesome-component></my-awesome-component>
<script>
  document.querySelector("my-awesome-component")
  .addEventListener("custom-event", (e) => {
    console.log(e.detail);
  });
</script>
            </code></pre>
          </section>
          <section data-auto-animate>
            <h3>Example</h3>
            <pre class="marker">attributes / hooks</pre>
            <pre
              data-id="code"
            ><code data-line-numbers="1-19" class="language-javascript">class MyAwesomeComponent extends HTMLElement {
  constructor() {
    super();
    const shadow = this.attachShadow({ mode: "open" });
    const button = document.createElement("button");

    button.textContent = "Click me!";
    button.addEventListener("click", () => {
      this.dispatchEvent(
        new CustomEvent("custom-event", {
          detail: "Hello World!"
        })
      );
    });
    shadow.appendChild(button);
  }
}

customElements.define("my-awesome-component", MyAwesomeComponent);
            </code></pre>
          </section>
          <section data-auto-animate>
            <h3>Example</h3>
            <pre class="marker">attributes / hooks</pre>
            <pre
              data-id="code"
            ><code data-line-numbers="1-35|3-5|23-32" class="hljs">class MyAwesomeComponent extends HTMLElement {

  static get observedAttributes() {
    return ['variant'];
  }

  constructor() {
    super();
    const shadow = this.attachShadow({ mode: "open" });
    const button = document.createElement("button");

    button.textContent = "Click me!";
    button.addEventListener("click", () => {
      this.dispatchEvent(
        new CustomEvent("custom-event", {
          detail: "Hello World!"
        })
      );
    });
    shadow.appendChild(button);
  }

  connectedCallback() {
    const variant = this.getAttribute('variant') || '';
    this.shadowRoot.querySelector('button').className = variant;
  }

  attributeChangedCallback(name, oldValue, newValue) {
    if(name === 'variant') {
      this.shadowRoot.querySelector('button').className = newValue;
    }
  }
}

customElements.define("my-awesome-component", MyAwesomeComponent);
            </code></pre>
            <aside class="notes">Custom element added to page.</aside>
          </section>
          <section data-auto-animate>
            <h3>Example</h3>
            <pre class="marker">attributes / hooks</pre>
            <pre
              data-id="code"
            ><code data-line-numbers="23-32" class="hljs">class MyAwesomeComponent extends HTMLElement {

  static get observedAttributes() {
    return ['variant'];
  }

  constructor() {
    super();
    const shadow = this.attachShadow({ mode: "open" });
    const button = document.createElement("button");

    button.textContent = "Click me!";
    button.addEventListener("click", () => {
      this.dispatchEvent(
        new CustomEvent("custom-event", {
          detail: "Hello World!"
        })
      );
    });
    shadow.appendChild(button);
  }

  disconnectedCallback() {
    const variant = this.getAttribute('variant') || '';
    this.shadowRoot.querySelector('button').className = variant;
  }

  attributeChangedCallback(name, oldValue, newValue) {
    if(name === 'variant') {
      this.shadowRoot.querySelector('button').className = newValue;
    }
  }
}

customElements.define("my-awesome-component", MyAwesomeComponent);
            </code></pre>
            <aside class="notes">Custom element removed from page.</aside>
          </section>
          <section data-auto-animate>
            <h3>Example</h3>
            <pre class="marker">attributes / hooks</pre>
            <pre
              data-id="code"
            ><code data-line-numbers="23-32" class="hljs">class MyAwesomeComponent extends HTMLElement {

  static get observedAttributes() {
    return ['variant'];
  }

  constructor() {
    super();
    const shadow = this.attachShadow({ mode: "open" });
    const button = document.createElement("button");

    button.textContent = "Click me!";
    button.addEventListener("click", () => {
      this.dispatchEvent(
        new CustomEvent("custom-event", {
          detail: "Hello World!"
        })
      );
    });
    shadow.appendChild(button);
  }

  connectedMoveCallback() {
    const variant = this.getAttribute('variant') || '';
    this.shadowRoot.querySelector('button').className = variant;
  }

  attributeChangedCallback(name, oldValue, newValue) {
    if(name === 'variant') {
      this.shadowRoot.querySelector('button').className = newValue;
    }
  }
}

customElements.define("my-awesome-component", MyAwesomeComponent);
            </code></pre>
            <aside class="notes">Custom element moved with moveBefore()</aside>
          </section>
          <section data-auto-animate>
            <h3>Example</h3>
            <pre class="marker">attributes / hooks</pre>
            <pre
              data-id="code"
            ><code data-line-numbers="23-32" class="hljs">class MyAwesomeComponent extends HTMLElement {

  static get observedAttributes() {
    return ['variant'];
  }

  constructor() {
    super();
    const shadow = this.attachShadow({ mode: "open" });
    const button = document.createElement("button");

    button.textContent = "Click me!";
    button.addEventListener("click", () => {
      this.dispatchEvent(
        new CustomEvent("custom-event", {
          detail: "Hello World!"
        })
      );
    });
    shadow.appendChild(button);
  }

  adoptedCallback() {
    const variant = this.getAttribute('variant') || '';
    this.shadowRoot.querySelector('button').className = variant;
  }

  attributeChangedCallback(name, oldValue, newValue) {
    if(name === 'variant') {
      this.shadowRoot.querySelector('button').className = newValue;
    }
  }
}

customElements.define("my-awesome-component", MyAwesomeComponent);
            </code></pre>
            <aside class="notes">Custom element moved to new page.</aside>
          </section>
          <section data-auto-animate>
            <h3>Example</h3>
            <pre class="marker">attributes / hooks</pre>
            <pre
              data-id="code"
            ><code data-line-numbers="23-32" class="hljs">class MyAwesomeComponent extends HTMLElement {

  static get observedAttributes() {
    return ['variant'];
  }

  constructor() {
    super();
    const shadow = this.attachShadow({ mode: "open" });
    const button = document.createElement("button");

    button.textContent = "Click me!";
    button.addEventListener("click", () => {
      this.dispatchEvent(
        new CustomEvent("custom-event", {
          detail: "Hello World!"
        })
      );
    });
    shadow.appendChild(button);
  }

  connectedCallback() {
    const variant = this.getAttribute('variant') || '';
    this.shadowRoot.querySelector('button').className = variant;
  }

  attributeChangedCallback(name, oldValue, newValue) {
    if(name === 'variant') {
      this.shadowRoot.querySelector('button').className = newValue;
    }
  }
}

customElements.define("my-awesome-component", MyAwesomeComponent);
            </code></pre>
          </section>
          <section data-auto-animate>
            <h3>Example</h3>
            <pre class="marker">usage</pre>
            <pre
              data-id="code"
            ><code data-line-numbers="3" class="hljs"><script type="module" src="<path-to-my-awesome-component>.(m)js"></script>
...
<my-awesome-component></my-awesome-component>
<script>
  document.querySelector("my-awesome-component")
  .addEventListener("custom-event", (e) => {
    console.log(e.detail);
  });
</script>
            </code></pre>
          </section>
          <section data-auto-animate>
            <h3>Example</h3>
            <pre class="marker">usage</pre>
            <pre
              data-id="code"
            ><code data-line-numbers="3" class="hljs"><script type="module" src="<path-to-my-awesome-component>.(m)js"></script>
...
<my-awesome-component variant="primary"></my-awesome-component>
<script>
  document.querySelector("my-awesome-component")
  .addEventListener("custom-event", (e) => {
    console.log(e.detail);
  });
</script>
            </code></pre>
          </section>
          <section data-auto-animate>
            <h3>Example</h3>
            <pre class="marker">slots / templates</pre>
            <pre
              data-id="code"
            ><code data-line-numbers="1-35" class="hljs">class MyAwesomeComponent extends HTMLElement {

  static get observedAttributes() {
    return ['variant'];
  }

  constructor() {
    super();
    const shadow = this.attachShadow({ mode: "open" });
    const button = document.createElement("button");

    button.textContent = "Click me!";
    button.addEventListener("click", () => {
      this.dispatchEvent(
        new CustomEvent("custom-event", {
          detail: "Hello World!"
        })
      );
    });
    shadow.appendChild(button);
  }

  adoptedCallback() {
    const variant = this.getAttribute('variant') || '';
    this.shadowRoot.querySelector('button').className = variant;
  }

  attributeChangedCallback(name, oldValue, newValue) {
    if(name === 'variant') {
      this.shadowRoot.querySelector('button').className = newValue;
    }
  }
}

customElements.define("my-awesome-component", MyAwesomeComponent);
            </code></pre>
          </section>
          <section data-auto-animate>
            <h3>Example</h3>
            <pre class="marker">slots / templates</pre>
            <pre
              data-id="code"
            ><code data-line-numbers="1-35|10-17|20-33" class="hljs">class MyAwesomeComponent extends HTMLElement {

  static get observedAttributes() {
    return ['variant'];
  }

  constructor() {
    super();
    const shadow = this.attachShadow({ mode: "open" });
    const template = document.createElement("template");
    template.innerHTML = `
      <button>
        <slot></slot>
      </button>
    `;

    shadow.appendChild(template.content.cloneNode(true));
  }

  connectedCallback() {
    const variant = this.getAttribute('variant') || '';
    const button = this.shadowRoot.querySelector('button');

    button.className = variant

    button.addEventListener("click", () => {
      this.dispatchEvent(
        new CustomEvent("custom-event", {
          detail: "Hello World!"
        })
      );
    });
  }

  attributeChangedCallback(name, oldValue, newValue) {
    if(name === 'variant') {
      this.shadowRoot.querySelector('button').className = newValue;
    }
  }
}

customElements.define("my-awesome-component", MyAwesomeComponent);
            </code></pre>
          </section>
          <section data-auto-animate>
            <h3>Example</h3>
            <pre class="marker">usage</pre>
            <pre
              data-id="code"
            ><code data-line-numbers class="hljs"><script type="module" src="<path-to-my-awesome-component>.(m)js"></script>
...
<my-awesome-component variant="primary"></my-awesome-component>
<script>
  document.querySelector("my-awesome-component")
  .addEventListener("custom-event", (e) => {
    console.log(e.detail);
  });
</script>
            </code></pre>
          </section>
          <section data-auto-animate>
            <h3>Example</h3>
            <pre class="marker">usage</pre>
            <pre
              data-id="code"
            ><code data-line-numbers class="hljs"><script type="module" src="<path-to-my-awesome-component>.(m)js"></script>
...
<my-awesome-component variant="primary">
  My Awesome Title
</my-awesome-component>
<script>
  document.querySelector("my-awesome-component")
  .addEventListener("custom-event", (e) => {
    console.log(e.detail);
  });
</script>
            </code></pre>
          </section>
          <section data-auto-animate>
            <h3>Example</h3>
            <pre class="marker">styles</pre>
            <pre
              data-id="code"
            ><code data-line-numbers="1-42" class="hljs">class MyAwesomeComponent extends HTMLElement {

  static get observedAttributes() {
    return ['variant'];
  }

  constructor() {
    super();
    const shadow = this.attachShadow({ mode: "open" });
    const template = document.createElement("template");
    template.innerHTML = `
      <button>
        <slot></slot>
      </button>
    `;

    shadow.appendChild(template.content.cloneNode(true));
  }

  connectedCallback() {
    const variant = this.getAttribute('variant') || '';
    const button = this.shadowRoot.querySelector('button');

    button.className = variant

    button.addEventListener("click", () => {
      this.dispatchEvent(
        new CustomEvent("custom-event", {
          detail: "Hello World!"
        })
      );
    });
  }

  attributeChangedCallback(name, oldValue, newValue) {
    if(name === 'variant') {
      this.shadowRoot.querySelector('button').className = newValue;
    }
  }
}

customElements.define("my-awesome-component", MyAwesomeComponent);
            </code></pre>
          </section>
          <section data-auto-animate>
            <h3>Example</h3>
            <pre class="marker">styles</pre>
            <pre
              data-id="code"
            ><code data-line-numbers="1-55|15-24|1,12" class="hljs">import myCss from 'path-to-css.css?inline';

class MyAwesomeComponent extends HTMLElement {

  static get observedAttributes() {
    return ['variant'];
  }

  constructor() {
    super();
    const shadow = this.attachShadow({ mode: "open" });
    shadowRoot.innerHTML = `<style>${myCss}</style>`
    const template = document.createElement("template");
    template.innerHTML = `
      <style>
        button {
          border: 1px solid #ccc;
          padding: 10px;
          border-radius: 5px;
        }
        ::slotted(h1) {
          color: darkblue;
        }
      </style>
      <button>
        <slot></slot>
      </button>
    `;

    shadow.appendChild(template.content.cloneNode(true));
  }

  connectedCallback() {
    const variant = this.getAttribute('variant') || '';
    const button = this.shadowRoot.querySelector('button');

    button.className = variant

    button.addEventListener("click", () => {
      this.dispatchEvent(
        new CustomEvent("custom-event", {
          detail: "Hello World!"
        })
      );
    });
  }

  attributeChangedCallback(name, oldValue, newValue) {
    if(name === 'variant') {
      this.shadowRoot.querySelector('button').className = newValue;
    }
  }
}

customElements.define("my-awesome-component", MyAwesomeComponent);
            </code></pre>
          </section>
        </section>
        <section>
          <section data-auto-animate>
            <h2>Advantages</h2>
            <ul>
              <li class="fragment fade-up">Standardized API</li>
              <li class="fragment fade-up">Encapsulation</li>
              <li class="fragment fade-up">Reusability</li>
              <li class="fragment fade-up">Interoperability</li>
              <li class="fragment fade-up">Future-Proof</li>
              <li class="fragment fade-up">Tooling Independence</li>
              <li class="fragment fade-up">Native Browser Support</li>
            </ul>
          </section>
          <section data-auto-animate>
            <h2>Challenges</h2>
            <ul>
              <li class="fragment fade-up">Debugging and Maintenance</li>
              <aside class="notes">
                <strong>Debugging and Maintenance</strong>
                <ul>
                  <li>
                    Debugging Web Components can be harder due to encapsulation
                    (e.g., inspecting Shadow DOM content in browser dev tools).
                  </li>
                  <li>
                    Maintaining a large library of Web Components can become
                    cumbersome without proper documentation and tooling. - mutch
                    boilerplate
                  </li>
                </ul>
              </aside>
              <li class="fragment fade-up">Testing Complexity</li>
              <aside class="notes">
                <strong>Testing Complexity</strong>
                <ul>
                  <li>
                    Testing Web Components can be more complex compared to
                    traditional components in frameworks.
                  </li>
                  <li>
                    Tools like Jest or Cypress may require additional
                    configuration to handle Shadow DOM and custom elements.
                  </li>
                </ul>
              </aside>
              <li class="fragment fade-up">Accessibility</li>
              <aside class="notes">
                <strong>Accessibility</strong>
                <ul>
                  <li>
                    Ensuring accessibility (e.g., ARIA roles, keyboard
                    navigation) requires extra effort, as Web Components do not
                    provide built-in accessibility features.
                  </li>
                  <li>
                    Developers must manually implement accessibility best
                    practices for each component.
                  </li>
                </ul>
              </aside>
              <li class="fragment fade-up">Adoption and Ecosystem</li>
              <aside class="notes">
                <strong>Adoption and Ecosystem</strong>
                <ul>
                  <li>
                    The ecosystem around Web Components is still maturing
                    compared to popular frameworks like React or Angular.
                  </li>
                  <li>
                    Limited availability of pre-built, high-quality Web
                    Components compared to framework-specific libraries.
                  </li>
                </ul>
              </aside>
              <li class="fragment fade-up">Integration with Frameworks</li>
              <aside class="notes">
                <strong>Integration with Frameworks</strong>
                <ul>
                  <li>
                    While Web Components are framework-agnostic, integrating
                    them into existing frameworks (e.g., React, Angular, Vue)
                    can be challenging:
                    <ul>
                      <li>
                        React, for example, doesn't natively support listening
                        to custom events emitted by Web Components.
                      </li>
                      <li>
                        Framework-specific tooling may not always play well with
                        Web Components.
                      </li>
                    </ul>
                  </li>
                </ul>
              </aside>
            </ul>
          </section>
        </section>
        <section>
          <section data-auto-animate>
            <h2>Lit</h2>
          </section>
          <section data-auto-animate>
            <h5>what is LIT?</h5>
            <ul>
              <li class="fragment fade-up">
                Lightweight library built on top of Web Components to simplify
                their development.
              </li>
              <li class="fragment fade-up">
                Provides a declarative syntax for rendering HTML templates,
                efficient reactivity for managing state and properties
              </li>
              <li class="fragment fade-up">
                Built-in support for scoped styles, all while adhering to web
                standards
              </li>
              <aside class="notes">
                Lit is designed to reduce boilerplate and improve developer
                ergonomics when working with Web Components.
              </aside>
            </ul>
          </section>
          <section data-auto-animate>
            <h3>Example</h3>
            <pre
              data-id="code"
            ><code data-line-numbers="1-55|55" class="hljs">import myCss from 'path-to-css.css?inline';

class MyAwesomeComponent extends HTMLElement {

  static get observedAttributes() {
    return ['variant'];
  }

  constructor() {
    super();
    const shadow = this.attachShadow({ mode: "open" });
    shadowRoot.innerHTML = `<style>${myCss}</style>`
    const template = document.createElement("template");
    template.innerHTML = `
      <style>
        button {
          border: 1px solid #ccc;
          padding: 10px;
          border-radius: 5px;
        }
        ::slotted(h1) {
          color: darkblue;
        }
      </style>
      <button>
        <slot></slot>
      </button>
    `;

    shadow.appendChild(template.content.cloneNode(true));
  }

  connectedCallback() {
    const variant = this.getAttribute('variant') || '';
    const button = this.shadowRoot.querySelector('button');

    button.className = variant

    button.addEventListener("click", () => {
      this.dispatchEvent(
        new CustomEvent("custom-event", {
          detail: "Hello World!"
        })
      );
    });
  }

  attributeChangedCallback(name, oldValue, newValue) {
    if(name === 'variant') {
      this.shadowRoot.querySelector('button').className = newValue;
    }
  }
}

customElements.define("my-awesome-component", MyAwesomeComponent);
            </code></pre>
          </section>
          <section data-auto-animate>
            <h3>Example</h3>
            <pre class="marker">custom elements</pre>
            <pre
              data-id="code"
            ><code data-line-numbers="1-55|12-34" class="hljs">import myCss from 'path-to-css.css?inline';
import { LitElement } from 'lit';
import { customElement } from 'lit/decorators.js';

@customElement('my-awesome-component')
class MyAwesomeComponent extends LitElement {

  static get observedAttributes() {
    return ['variant'];
  }

  constructor() {
    super();
    const shadow = this.attachShadow({ mode: "open" });
    shadowRoot.innerHTML = `<style>${myCss}</style>`
    const template = document.createElement("template");
    template.innerHTML = `
      <style>
        button {
          border: 1px solid #ccc;
          padding: 10px;
          border-radius: 5px;
        }
        ::slotted(h1) {
          color: darkblue;
        }
      </style>
      <button>
        <slot></slot>
      </button>
    `;

    shadow.appendChild(template.content.cloneNode(true));
  }

  connectedCallback() {
    const variant = this.getAttribute('variant') || '';
    const button = this.shadowRoot.querySelector('button');

    button.className = variant

    button.addEventListener("click", () => {
      this.dispatchEvent(
        new CustomEvent("custom-event", {
          detail: "Hello World!"
        })
      );
    });
  }

  attributeChangedCallback(name, oldValue, newValue) {
    if(name === 'variant') {
      this.shadowRoot.querySelector('button').className = newValue;
    }
  }
}
            </code></pre>
          </section>
          <section data-auto-animate>
            <h3>Example</h3>
            <pre class="marker">declarative template / scoped styles</pre>
            <pre
              data-id="code"
            ><code data-line-numbers="1-47|23-46" class="hljs">import { html, css, LitElement } from 'lit';
import { customElement } from 'lit/decorators.js';

@customElement('my-awesome-component')
class MyAwesomeComponent extends LitElement {
  static styles = css`
    button {
      border: 1px solid #ccc;
      padding: 10px;
      border-radius: 5px;
    }
    ::slotted(h1) {
      color: darkblue;
    }
  `;

  render() {
    return html`<button>
      <slot></slot>
    </button>`;
  }

  static get observedAttributes() {
    return ['variant'];
  }

  connectedCallback() {
    const variant = this.getAttribute('variant') || '';
    const button = this.shadowRoot.querySelector('button');

    button.className = variant

    button.addEventListener("click", () => {
      this.dispatchEvent(
        new CustomEvent("custom-event", {
          detail: "Hello World!"
        })
      );
    });
  }

  attributeChangedCallback(name, oldValue, newValue) {
    if(name === 'variant') {
      this.shadowRoot.querySelector('button').className = newValue;
    }
  }
}
            </code></pre>
          </section>
          <section data-auto-animate>
            <h3>Example</h3>
            <pre class="marker">reactive properties / events</pre>
            <pre
              data-id="code"
            ><code data-line-numbers="1-33|17-18,20-26,29" class="hljs">import { html, css, LitElement } from 'lit';
import { customElement } from 'lit/decorators.js';

@customElement('my-awesome-component')
class MyAwesomeComponent extends LitElement {
  static styles = css`
    button {
      border: 1px solid #ccc;
      padding: 10px;
      border-radius: 5px;
    }
    ::slotted(h1) {
      color: darkblue;
    }
  `;

  @property()
  variant = '';

  private _handleClick(e: Event) {
    this.dispatchEvent(
      new CustomEvent("custom-event", {
        detail: "Hello World!"
      })
    );
  }

  render() {
    return html`<button @click=${this._handleClick} class="${this.variant}">
      <slot></slot>
    </button>`;
  }
}
            </code></pre>
          </section>
          <section data-auto-animate>
            <h3>Example</h3>
            <pre class="marker">reactive properties / events</pre>
            <pre
              data-id="code"
            ><code data-line-numbers="20-21,33|32-33" class="hljs">import { html, css, LitElement } from 'lit';
import { customElement } from 'lit/decorators.js';

@customElement('my-awesome-component')
class MyAwesomeComponent extends LitElement {
  static styles = css`
    button {
      border: 1px solid #ccc;
      padding: 10px;
      border-radius: 5px;
    }
    ::slotted(h1) {
      color: darkblue;
    }
  `;

  @property()
  variant = '';

  @property({type: Boolean})
  disabled = false;

  private _handleClick(e: Event) {
    this.dispatchEvent(
      new CustomEvent("custom-event", {
        detail: "Hello World!"
      })
    );
  }

  render() {
    const classes = { variant: this.variant };
    return html`<button @click=${this._handleClick} ?disabled=${disabled} class=${classMap(classes)}>
      <slot></slot>
    </button>`;
  }
}
            </code></pre>
          </section>
          <section data-auto-animate>
            <h3>Directives</h3>
          </section>
          <section data-auto-animate>
            <h5>What are Directives?</h5>
            <ul>
              <li class="fragment fade-up">
                Special functions that extend the behavior of templates.
              </li>
              <li class="fragment fade-up">
                Allow you to add dynamic behavior, optimize rendering, and
                handle complex logic directly in your HTML templates.
              </li>
            </ul>
          </section>
          <section data-auto-animate>
            <strong>map</strong>
            <pre data-id="code"><code data-trim class="hljs">
              class MyElement extends LitElement {
                render() {
                  return html`
                    ${map(range(8), (i) => html`${i + 1}`)}
                  `;
                }
              }
            </code></pre>
          </section>
          <section data-auto-animate>
            <strong>when</strong>
            <pre data-id="code"><code data-trim class="hljs">
              class MyElement extends LitElement {
                @property()
                isLoading = true;

                render() {
                  return html`
                    ${when(
                        isLoading,
                        () => html`<p>Loading...</p>`,
                        () => html`<p>Content loaded!</p>`
                      )}
                  `;
                }
              }
            </code></pre>
          </section>
        </section>
        <section>
          <section data-auto-animate>
            <h2>Advantages</h2>
            <ul>
              <li class="fragment fade-up">Simplified Development</li>
              <li class="fragment fade-up">Reactivity</li>
              <li class="fragment fade-up">Directives</li>
              <li class="fragment fade-up">Scoped Styles</li>
              <li class="fragment fade-up">Performance</li>
              <li class="fragment fade-up">Community and Ecosystem</li>
              <li class="fragment fade-up">Framework-Agnostic</li>
            </ul>
            <aside class="notes">
              <strong>Performance</strong>
              <ul>
                <li>Weighing in at around 5 KB (minified and compressed)</li>
                <li>
                  rendering is blazing fast, because Lit touches only the
                  dynamic parts of your UI when updating
                </li>
              </ul>
            </aside>
          </section>
          <section data-auto-animate>
            <h2>Challenges</h2>
            <ul>
              <li class="fragment fade-up">Dependency</li>
              <li class="fragment fade-up">Abstraction</li>
              <li class="fragment fade-up">Not a Standard</li>
            </ul>
          </section>
        </section>
        <section><h3>Question?</h3></section>
        <section><h3>Thanks for listeningðŸŽ‰</h3></section>
      </div>
    </div>

    <script src="dist/reveal.js"></script>
    <script src="plugin/notes/notes.js"></script>
    <script src="plugin/markdown/markdown.js"></script>
    <script src="plugin/highlight/highlight.js"></script>
    <script src="../plugin/notes/notes.js"></script>
    <script src="../plugin/math/math.js"></script>
    <script>
      Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,

        plugins: [
          RevealMarkdown,
          RevealHighlight,
          RevealNotes,
          RevealMath.KaTeX,
        ],
      });
    </script>
  </body>
</html>
